# 📦 KUWOTECH 백엔드 코드 전체

> **작성일**: 2025-10-04
> **버전**: 1.0
> **목적**: 프로덕션급 백엔드 전체 코드

---

## 📑 목차

1. [프로젝트 구조](#1-프로젝트-구조)
2. [Config 파일](#2-config-파일)
3. [Models](#3-models)
4. [Controllers](#4-controllers)
5. [Routes](#5-routes)
6. [Middleware](#6-middleware)
7. [Services](#7-services)
8. [Utils](#8-utils)
9. [Scripts](#9-scripts)

---

## 1. 프로젝트 구조

```
backend/
├── config/
│   ├── database.js          # MySQL 연결 설정
│   └── auth.js              # JWT 설정
│
├── models/
│   ├── Company.js           # 거래처 모델
│   ├── Employee.js          # 직원 모델
│   ├── Report.js            # 보고서 모델
│   └── ChangeHistory.js     # 변경이력 모델
│
├── controllers/
│   ├── authController.js    # 인증 컨트롤러
│   ├── companyController.js # 거래처 CRUD
│   ├── reportController.js  # 보고서 CRUD
│   ├── employeeController.js# 직원 관리
│   └── kpiController.js     # KPI 계산
│
├── routes/
│   ├── auth.js
│   ├── companies.js
│   ├── reports.js
│   ├── employees.js
│   └── kpi.js
│
├── middleware/
│   ├── auth.js              # JWT 인증
│   ├── validate.js          # 입력 검증
│   └── errorHandler.js      # 에러 처리
│
├── services/
│   ├── companyService.js    # 비즈니스 로직
│   ├── reportService.js
│   ├── kpiService.js
│   └── excelService.js
│
├── utils/
│   ├── logger.js
│   └── validator.js
│
├── scripts/
│   ├── init-db.js           # DB 초기화
│   └── migrate.js           # 마이그레이션
│
├── .env.example
├── .gitignore
├── package.json
└── server.js
```

---

## 2. Config 파일

### 2-1. database.js

**backend/config/database.js:**

```javascript
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';

dotenv.config();

let pool;

export async function createPool() {
  if (!pool) {
    pool = mysql.createPool({
      uri: process.env.DATABASE_URL,
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0,
      enableKeepAlive: true,
      keepAliveInitialDelay: 0
    });

    console.log('✅ MySQL Pool 생성 완료');
  }

  return pool;
}

export async function getConnection() {
  if (!pool) {
    await createPool();
  }

  return pool.getConnection();
}

export default pool;
```

### 2-2. auth.js

**backend/config/auth.js:**

```javascript
import dotenv from 'dotenv';

dotenv.config();

export const authConfig = {
  jwt: {
    secret: process.env.JWT_SECRET || 'default_secret_change_in_production',
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '30d'
  },
  bcrypt: {
    saltRounds: 10
  }
};
```

---

## 3. Models

### 3-1. Company.js

**backend/models/Company.js:**

```javascript
import { createPool } from '../config/database.js';

class Company {
  static async findAll(filters = {}) {
    const pool = await createPool();
    let query = 'SELECT * FROM companies WHERE 1=1';
    const params = [];

    if (filters.manager) {
      query += ' AND internalManager = ?';
      params.push(filters.manager);
    }

    if (filters.status) {
      query += ' AND businessStatus = ?';
      params.push(filters.status);
    }

    query += ' ORDER BY createdAt DESC';

    const [rows] = await pool.execute(query, params);
    return rows;
  }

  static async findById(id) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM companies WHERE id = ?',
      [id]
    );
    return rows[0];
  }

  static async findByKeyValue(keyValue) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM companies WHERE keyValue = ?',
      [keyValue]
    );
    return rows[0];
  }

  static async create(data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `INSERT INTO companies (
        keyValue, companyNameERP, finalCompanyName,
        companyCode, representative, internalManager,
        externalManager, businessStatus, accumulatedSales,
        accumulatedCollection, accountsReceivable,
        salesProduct, businessActivity, remarks, updatedBy
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        data.keyValue,
        data.companyNameERP,
        data.finalCompanyName,
        data.companyCode,
        data.representative,
        data.internalManager,
        data.externalManager,
        data.businessStatus || '거래중',
        data.accumulatedSales || 0,
        data.accumulatedCollection || 0,
        data.accountsReceivable || 0,
        data.salesProduct,
        data.businessActivity,
        data.remarks,
        data.updatedBy
      ]
    );
    return result.insertId;
  }

  static async update(id, data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE companies SET
        companyNameERP = ?,
        finalCompanyName = ?,
        companyCode = ?,
        representative = ?,
        internalManager = ?,
        externalManager = ?,
        businessStatus = ?,
        accumulatedSales = ?,
        accumulatedCollection = ?,
        accountsReceivable = ?,
        lastPaymentDate = ?,
        lastPaymentAmount = ?,
        salesProduct = ?,
        businessActivity = ?,
        remarks = ?,
        updatedBy = ?
      WHERE id = ?`,
      [
        data.companyNameERP,
        data.finalCompanyName,
        data.companyCode,
        data.representative,
        data.internalManager,
        data.externalManager,
        data.businessStatus,
        data.accumulatedSales,
        data.accumulatedCollection,
        data.accountsReceivable,
        data.lastPaymentDate,
        data.lastPaymentAmount,
        data.salesProduct,
        data.businessActivity,
        data.remarks,
        data.updatedBy,
        id
      ]
    );
    return result.affectedRows > 0;
  }

  static async delete(id) {
    const pool = await createPool();
    const [result] = await pool.execute(
      'DELETE FROM companies WHERE id = ?',
      [id]
    );
    return result.affectedRows > 0;
  }

  static async findByManager(manager) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM companies WHERE internalManager = ? ORDER BY companyNameERP',
      [manager]
    );
    return rows;
  }
}

export default Company;
```

### 3-2. Employee.js

**backend/models/Employee.js:**

```javascript
import { createPool } from '../config/database.js';
import bcrypt from 'bcryptjs';

class Employee {
  static async findAll() {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT id, username, name, email, phone, department,
              role, position, isActive, lastLogin, createdAt
       FROM employees
       ORDER BY department, name`
    );
    return rows;
  }

  static async findById(id) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT id, username, name, email, phone, department,
              role, position, isActive, lastLogin, createdAt
       FROM employees WHERE id = ?`,
      [id]
    );
    return rows[0];
  }

  static async findByUsername(username) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM employees WHERE username = ?',
      [username]
    );
    return rows[0];
  }

  static async create(data) {
    const pool = await createPool();
    const hashedPassword = await bcrypt.hash(data.password, 10);

    const [result] = await pool.execute(
      `INSERT INTO employees (
        username, password, name, email, phone,
        department, role, position, isActive
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        data.username,
        hashedPassword,
        data.name,
        data.email,
        data.phone,
        data.department,
        data.role || 'sales',
        data.position,
        true
      ]
    );
    return result.insertId;
  }

  static async update(id, data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE employees SET
        name = ?, email = ?, phone = ?,
        department = ?, role = ?, position = ?,
        isActive = ?
      WHERE id = ?`,
      [
        data.name,
        data.email,
        data.phone,
        data.department,
        data.role,
        data.position,
        data.isActive,
        id
      ]
    );
    return result.affectedRows > 0;
  }

  static async updatePassword(id, newPassword) {
    const pool = await createPool();
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    const [result] = await pool.execute(
      'UPDATE employees SET password = ? WHERE id = ?',
      [hashedPassword, id]
    );
    return result.affectedRows > 0;
  }

  static async verifyPassword(plainPassword, hashedPassword) {
    return await bcrypt.compare(plainPassword, hashedPassword);
  }

  static async updateLastLogin(id) {
    const pool = await createPool();
    await pool.execute(
      'UPDATE employees SET lastLogin = NOW() WHERE id = ?',
      [id]
    );
  }

  static async delete(id) {
    const pool = await createPool();
    const [result] = await pool.execute(
      'UPDATE employees SET isActive = false WHERE id = ?',
      [id]
    );
    return result.affectedRows > 0;
  }
}

export default Employee;
```

### 3-3. Report.js

**backend/models/Report.js:**

```javascript
import { createPool } from '../config/database.js';

class Report {
  static async findAll(filters = {}) {
    const pool = await createPool();
    let query = 'SELECT * FROM reports WHERE 1=1';
    const params = [];

    if (filters.submittedBy) {
      query += ' AND submittedBy = ?';
      params.push(filters.submittedBy);
    }

    if (filters.status) {
      query += ' AND status = ?';
      params.push(filters.status);
    }

    if (filters.startDate) {
      query += ' AND submittedDate >= ?';
      params.push(filters.startDate);
    }

    if (filters.endDate) {
      query += ' AND submittedDate <= ?';
      params.push(filters.endDate);
    }

    query += ' ORDER BY submittedDate DESC';

    const [rows] = await pool.execute(query, params);
    return rows;
  }

  static async findById(id) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM reports WHERE reportId = ?',
      [id]
    );
    return rows[0];
  }

  static async create(data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `INSERT INTO reports (
        submittedBy, companyId, reportType,
        content, status
      ) VALUES (?, ?, ?, ?, 'pending')`,
      [
        data.submittedBy,
        data.companyId,
        data.reportType,
        data.content
      ]
    );
    return result.insertId;
  }

  static async update(id, data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE reports SET
        reportType = ?,
        content = ?
      WHERE reportId = ? AND status = 'pending'`,
      [
        data.reportType,
        data.content,
        id
      ]
    );
    return result.affectedRows > 0;
  }

  static async approve(id, confirmedBy, comment = '') {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE reports SET
        status = 'confirmed',
        confirmedBy = ?,
        confirmedDate = NOW(),
        adminComment = ?
      WHERE reportId = ? AND status = 'pending'`,
      [confirmedBy, comment, id]
    );
    return result.affectedRows > 0;
  }

  static async reject(id, confirmedBy, comment) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE reports SET
        status = 'rejected',
        confirmedBy = ?,
        confirmedDate = NOW(),
        adminComment = ?
      WHERE reportId = ? AND status = 'pending'`,
      [confirmedBy, comment, id]
    );
    return result.affectedRows > 0;
  }

  static async findByUser(username) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM reports WHERE submittedBy = ? ORDER BY submittedDate DESC',
      [username]
    );
    return rows;
  }

  static async findPending() {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM reports WHERE status = ? ORDER BY submittedDate ASC',
      ['pending']
    );
    return rows;
  }
}

export default Report;
```

### 3-4. ChangeHistory.js

**backend/models/ChangeHistory.js:**

```javascript
import { createPool } from '../config/database.js';

class ChangeHistory {
  static async create(data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `INSERT INTO change_history (
        targetTable, targetId, operation,
        userId, beforeData, afterData,
        ipAddress, userAgent
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        data.targetTable,
        data.targetId,
        data.operation,
        data.userId,
        JSON.stringify(data.beforeData),
        JSON.stringify(data.afterData),
        data.ipAddress,
        data.userAgent
      ]
    );
    return result.insertId;
  }

  static async findByTarget(tableName, targetId) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT * FROM change_history
       WHERE targetTable = ? AND targetId = ?
       ORDER BY createdAt DESC`,
      [tableName, targetId]
    );
    return rows;
  }

  static async findByUser(userId, limit = 50) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT * FROM change_history
       WHERE userId = ?
       ORDER BY createdAt DESC
       LIMIT ?`,
      [userId, limit]
    );
    return rows;
  }
}

export default ChangeHistory;
```

---

## 4. Controllers

### 4-1. authController.js

**backend/controllers/authController.js:**

```javascript
import jwt from 'jsonwebtoken';
import Employee from '../models/Employee.js';
import { authConfig } from '../config/auth.js';

class AuthController {
  static async login(req, res, next) {
    try {
      const { username, password } = req.body;

      // 사용자 조회
      const employee = await Employee.findByUsername(username);
      if (!employee) {
        return res.status(401).json({
          success: false,
          error: { message: '사용자명 또는 비밀번호가 잘못되었습니다' }
        });
      }

      // 활성 계정 확인
      if (!employee.isActive) {
        return res.status(403).json({
          success: false,
          error: { message: '비활성화된 계정입니다' }
        });
      }

      // 비밀번호 확인
      const isValid = await Employee.verifyPassword(password, employee.password);
      if (!isValid) {
        return res.status(401).json({
          success: false,
          error: { message: '사용자명 또는 비밀번호가 잘못되었습니다' }
        });
      }

      // JWT 토큰 생성
      const token = jwt.sign(
        {
          id: employee.id,
          username: employee.username,
          role: employee.role,
          name: employee.name
        },
        authConfig.jwt.secret,
        { expiresIn: authConfig.jwt.expiresIn }
      );

      const refreshToken = jwt.sign(
        { id: employee.id },
        authConfig.jwt.secret,
        { expiresIn: authConfig.jwt.refreshExpiresIn }
      );

      // 마지막 로그인 업데이트
      await Employee.updateLastLogin(employee.id);

      res.json({
        success: true,
        data: {
          token,
          refreshToken,
          user: {
            id: employee.id,
            username: employee.username,
            name: employee.name,
            role: employee.role,
            department: employee.department
          }
        },
        message: '로그인 성공'
      });

    } catch (error) {
      next(error);
    }
  }

  static async logout(req, res, next) {
    try {
      res.json({
        success: true,
        message: '로그아웃 되었습니다'
      });
    } catch (error) {
      next(error);
    }
  }

  static async refresh(req, res, next) {
    try {
      const { refreshToken } = req.body;

      const decoded = jwt.verify(refreshToken, authConfig.jwt.secret);
      const employee = await Employee.findById(decoded.id);

      if (!employee || !employee.isActive) {
        return res.status(401).json({
          success: false,
          error: { message: '유효하지 않은 토큰입니다' }
        });
      }

      const newToken = jwt.sign(
        {
          id: employee.id,
          username: employee.username,
          role: employee.role,
          name: employee.name
        },
        authConfig.jwt.secret,
        { expiresIn: authConfig.jwt.expiresIn }
      );

      res.json({
        success: true,
        data: { token: newToken },
        message: '토큰이 갱신되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async getMe(req, res, next) {
    try {
      const employee = await Employee.findById(req.user.id);

      res.json({
        success: true,
        data: {
          id: employee.id,
          username: employee.username,
          name: employee.name,
          email: employee.email,
          phone: employee.phone,
          department: employee.department,
          role: employee.role,
          position: employee.position
        }
      });

    } catch (error) {
      next(error);
    }
  }
}

export default AuthController;
```

### 4-2. companyController.js

**backend/controllers/companyController.js:**

```javascript
import Company from '../models/Company.js';
import ChangeHistory from '../models/ChangeHistory.js';

class CompanyController {
  static async getAll(req, res, next) {
    try {
      const filters = {
        manager: req.query.manager,
        status: req.query.status
      };

      const companies = await Company.findAll(filters);

      res.json({
        success: true,
        data: { companies }
      });

    } catch (error) {
      next(error);
    }
  }

  static async getById(req, res, next) {
    try {
      const company = await Company.findById(req.params.id);

      if (!company) {
        return res.status(404).json({
          success: false,
          error: { message: '거래처를 찾을 수 없습니다' }
        });
      }

      res.json({
        success: true,
        data: company
      });

    } catch (error) {
      next(error);
    }
  }

  static async create(req, res, next) {
    try {
      const companyData = {
        ...req.body,
        updatedBy: req.user.name
      };

      const companyId = await Company.create(companyData);

      // 변경 이력 기록
      await ChangeHistory.create({
        targetTable: 'companies',
        targetId: companyId,
        operation: 'CREATE',
        userId: req.user.username,
        beforeData: null,
        afterData: companyData,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.status(201).json({
        success: true,
        data: { id: companyId },
        message: '거래처가 생성되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async update(req, res, next) {
    try {
      const companyId = req.params.id;
      const beforeData = await Company.findById(companyId);

      if (!beforeData) {
        return res.status(404).json({
          success: false,
          error: { message: '거래처를 찾을 수 없습니다' }
        });
      }

      const companyData = {
        ...req.body,
        updatedBy: req.user.name
      };

      await Company.update(companyId, companyData);

      // 변경 이력 기록
      await ChangeHistory.create({
        targetTable: 'companies',
        targetId: companyId,
        operation: 'UPDATE',
        userId: req.user.username,
        beforeData,
        afterData: companyData,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({
        success: true,
        message: '거래처가 수정되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async delete(req, res, next) {
    try {
      const companyId = req.params.id;
      const beforeData = await Company.findById(companyId);

      if (!beforeData) {
        return res.status(404).json({
          success: false,
          error: { message: '거래처를 찾을 수 없습니다' }
        });
      }

      await Company.delete(companyId);

      // 변경 이력 기록
      await ChangeHistory.create({
        targetTable: 'companies',
        targetId: companyId,
        operation: 'DELETE',
        userId: req.user.username,
        beforeData,
        afterData: null,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({
        success: true,
        message: '거래처가 삭제되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async getMy(req, res, next) {
    try {
      const companies = await Company.findByManager(req.user.name);

      res.json({
        success: true,
        data: { companies }
      });

    } catch (error) {
      next(error);
    }
  }
}

export default CompanyController;
```

### 4-3. reportController.js

**backend/controllers/reportController.js:**

```javascript
import Report from '../models/Report.js';
import ChangeHistory from '../models/ChangeHistory.js';

class ReportController {
  static async getAll(req, res, next) {
    try {
      const filters = {
        submittedBy: req.query.submittedBy,
        status: req.query.status,
        startDate: req.query.startDate,
        endDate: req.query.endDate
      };

      const reports = await Report.findAll(filters);

      res.json({
        success: true,
        data: { reports }
      });

    } catch (error) {
      next(error);
    }
  }

  static async getById(req, res, next) {
    try {
      const report = await Report.findById(req.params.id);

      if (!report) {
        return res.status(404).json({
          success: false,
          error: { message: '보고서를 찾을 수 없습니다' }
        });
      }

      res.json({
        success: true,
        data: report
      });

    } catch (error) {
      next(error);
    }
  }

  static async create(req, res, next) {
    try {
      const reportData = {
        ...req.body,
        submittedBy: req.user.id
      };

      const reportId = await Report.create(reportData);

      // 변경 이력 기록
      await ChangeHistory.create({
        targetTable: 'reports',
        targetId: reportId,
        operation: 'CREATE',
        userId: req.user.username,
        beforeData: null,
        afterData: reportData,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.status(201).json({
        success: true,
        data: { reportId },
        message: '보고서가 제출되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async update(req, res, next) {
    try {
      const reportId = req.params.id;
      const beforeData = await Report.findById(reportId);

      if (!beforeData) {
        return res.status(404).json({
          success: false,
          error: { message: '보고서를 찾을 수 없습니다' }
        });
      }

      // 본인 보고서만 수정 가능
      if (beforeData.submittedBy !== req.user.id && req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: { message: '권한이 없습니다' }
        });
      }

      const updated = await Report.update(reportId, req.body);

      if (!updated) {
        return res.status(400).json({
          success: false,
          error: { message: '대기 상태의 보고서만 수정할 수 있습니다' }
        });
      }

      res.json({
        success: true,
        message: '보고서가 수정되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async approve(req, res, next) {
    try {
      const reportId = req.params.id;
      const { comment } = req.body;

      const updated = await Report.approve(reportId, req.user.id, comment);

      if (!updated) {
        return res.status(400).json({
          success: false,
          error: { message: '대기 상태의 보고서만 승인할 수 있습니다' }
        });
      }

      res.json({
        success: true,
        message: '보고서가 승인되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async reject(req, res, next) {
    try {
      const reportId = req.params.id;
      const { comment } = req.body;

      if (!comment) {
        return res.status(400).json({
          success: false,
          error: { message: '반려 사유를 입력해주세요' }
        });
      }

      const updated = await Report.reject(reportId, req.user.id, comment);

      if (!updated) {
        return res.status(400).json({
          success: false,
          error: { message: '대기 상태의 보고서만 반려할 수 있습니다' }
        });
      }

      res.json({
        success: true,
        message: '보고서가 반려되었습니다'
      });

    } catch (error) {
      next(error);
    }
  }

  static async getMy(req, res, next) {
    try {
      const reports = await Report.findByUser(req.user.id);

      res.json({
        success: true,
        data: { reports }
      });

    } catch (error) {
      next(error);
    }
  }
}

export default ReportController;
```

---

## 5. Routes

### 5-1. auth.js

**backend/routes/auth.js:**

```javascript
import express from 'express';
import AuthController from '../controllers/authController.js';
import { authMiddleware } from '../middleware/auth.js';

const router = express.Router();

router.post('/login', AuthController.login);
router.post('/logout', authMiddleware, AuthController.logout);
router.post('/refresh', AuthController.refresh);
router.get('/me', authMiddleware, AuthController.getMe);

export default router;
```

### 5-2. companies.js

**backend/routes/companies.js:**

```javascript
import express from 'express';
import CompanyController from '../controllers/companyController.js';
import { authMiddleware, isAdmin } from '../middleware/auth.js';

const router = express.Router();

// 모든 라우트에 인증 필요
router.use(authMiddleware);

router.get('/', CompanyController.getAll);
router.get('/my', CompanyController.getMy);
router.get('/:id', CompanyController.getById);
router.post('/', CompanyController.create);
router.put('/:id', CompanyController.update);
router.delete('/:id', isAdmin, CompanyController.delete);

export default router;
```

### 5-3. reports.js

**backend/routes/reports.js:**

```javascript
import express from 'express';
import ReportController from '../controllers/reportController.js';
import { authMiddleware, isAdmin } from '../middleware/auth.js';

const router = express.Router();

router.use(authMiddleware);

router.get('/', ReportController.getAll);
router.get('/my', ReportController.getMy);
router.get('/:id', ReportController.getById);
router.post('/', ReportController.create);
router.put('/:id', ReportController.update);
router.put('/:id/approve', isAdmin, ReportController.approve);
router.put('/:id/reject', isAdmin, ReportController.reject);

export default router;
```

---

## 6. Middleware

### 6-1. auth.js

**backend/middleware/auth.js:**

```javascript
import jwt from 'jsonwebtoken';
import { authConfig } from '../config/auth.js';

export function authMiddleware(req, res, next) {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: { message: '인증 토큰이 없습니다' }
      });
    }

    const token = authHeader.substring(7);
    const decoded = jwt.verify(token, authConfig.jwt.secret);

    req.user = decoded;
    next();

  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        error: { message: '토큰이 만료되었습니다' }
      });
    }

    return res.status(401).json({
      success: false,
      error: { message: '유효하지 않은 토큰입니다' }
    });
  }
}

export function isAdmin(req, res, next) {
  if (req.user.role !== 'admin') {
    return res.status(403).json({
      success: false,
      error: { message: '관리자 권한이 필요합니다' }
    });
  }
  next();
}
```

### 6-2. errorHandler.js

**backend/middleware/errorHandler.js:**

```javascript
export function errorHandler(err, req, res, next) {
  console.error('Error:', err);

  const statusCode = err.statusCode || 500;
  const message = err.message || '서버 오류가 발생했습니다';

  res.status(statusCode).json({
    success: false,
    error: {
      message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
}
```

---

## 7. Services

### 7-1. kpiService.js

**backend/services/kpiService.js:**

```javascript
import { createPool } from '../config/database.js';

class KPIService {
  static async calculateUserKPI(userId) {
    const pool = await createPool();

    // 거래처 통계
    const [companies] = await pool.execute(
      `SELECT
        COUNT(*) as total_companies,
        SUM(accumulatedSales) as total_sales,
        SUM(accumulatedCollection) as total_collection,
        SUM(accountsReceivable) as total_receivables
       FROM companies
       WHERE internalManager = (SELECT name FROM employees WHERE id = ?)`,
      [userId]
    );

    // 보고서 통계
    const [reports] = await pool.execute(
      `SELECT
        COUNT(*) as total_reports,
        SUM(CASE WHEN status = 'confirmed' THEN 1 ELSE 0 END) as approved_reports
       FROM reports
       WHERE submittedBy = ?`,
      [userId]
    );

    const companyData = companies[0];
    const reportData = reports[0];

    return {
      companies: {
        total: companyData.total_companies || 0,
        totalSales: companyData.total_sales || 0,
        totalCollection: companyData.total_collection || 0,
        totalReceivables: companyData.total_receivables || 0
      },
      reports: {
        total: reportData.total_reports || 0,
        approved: reportData.approved_reports || 0,
        approvalRate: reportData.total_reports > 0
          ? (reportData.approved_reports / reportData.total_reports * 100).toFixed(2)
          : 0
      }
    };
  }
}

export default KPIService;
```

---

## 8. Utils

### 8-1. logger.js

**backend/utils/logger.js:**

```javascript
export function log(level, message, data = {}) {
  const timestamp = new Date().toISOString();
  console.log(JSON.stringify({
    timestamp,
    level,
    message,
    ...data
  }));
}

export const logger = {
  info: (message, data) => log('INFO', message, data),
  error: (message, data) => log('ERROR', message, data),
  warn: (message, data) => log('WARN', message, data),
  debug: (message, data) => log('DEBUG', message, data)
};
```

---

## 9. Scripts

### 9-1. migrate.js

**backend/scripts/migrate.js:**

```javascript
import { createPool } from '../config/database.js';
import fs from 'fs';

async function migrate() {
  const pool = await createPool();

  try {
    // backup.json 읽기
    const backupData = JSON.parse(
      fs.readFileSync('./backup.json', 'utf8')
    );

    console.log('마이그레이션 시작...');

    // Companies
    for (const company of backupData.data.companies || []) {
      await pool.execute(
        `INSERT IGNORE INTO companies (keyValue, companyNameERP, finalCompanyName, ...)
         VALUES (?, ?, ?, ...)`,
        [company.keyValue, company.companyNameERP, ...]
      );
    }

    console.log(`✅ ${backupData.data.companies?.length || 0}개 거래처 마이그레이션 완료`);

    // Reports
    for (const report of backupData.data.reports || []) {
      await pool.execute(
        `INSERT INTO reports (submittedBy, companyId, ...)
         VALUES (?, ?, ...)`,
        [report.submittedBy, report.companyId, ...]
      );
    }

    console.log(`✅ ${backupData.data.reports?.length || 0}개 보고서 마이그레이션 완료`);

    console.log('🎉 마이그레이션 완료!');

  } catch (error) {
    console.error('❌ 마이그레이션 실패:', error);
  } finally {
    process.exit(0);
  }
}

migrate();
```

---

**문서 버전**: 1.0
**최종 수정**: 2025-10-04

**📦 이 코드를 backend 폴더에 배치하세요!**
