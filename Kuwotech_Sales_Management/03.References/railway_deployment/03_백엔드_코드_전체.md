# ğŸ“¦ KUWOTECH ë°±ì—”ë“œ ì½”ë“œ ì „ì²´

> **ì‘ì„±ì¼**: 2025-10-04
> **ë²„ì „**: 1.0
> **ëª©ì **: í”„ë¡œë•ì…˜ê¸‰ ë°±ì—”ë“œ ì „ì²´ ì½”ë“œ

---

## ğŸ“‘ ëª©ì°¨

1. [í”„ë¡œì íŠ¸ êµ¬ì¡°](#1-í”„ë¡œì íŠ¸-êµ¬ì¡°)
2. [Config íŒŒì¼](#2-config-íŒŒì¼)
3. [Models](#3-models)
4. [Controllers](#4-controllers)
5. [Routes](#5-routes)
6. [Middleware](#6-middleware)
7. [Services](#7-services)
8. [Utils](#8-utils)
9. [Scripts](#9-scripts)

---

## 1. í”„ë¡œì íŠ¸ êµ¬ì¡°

```
backend/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ database.js          # MySQL ì—°ê²° ì„¤ì •
â”‚   â””â”€â”€ auth.js              # JWT ì„¤ì •
â”‚
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ Company.js           # ê±°ë˜ì²˜ ëª¨ë¸
â”‚   â”œâ”€â”€ Employee.js          # ì§ì› ëª¨ë¸
â”‚   â”œâ”€â”€ Report.js            # ë³´ê³ ì„œ ëª¨ë¸
â”‚   â””â”€â”€ ChangeHistory.js     # ë³€ê²½ì´ë ¥ ëª¨ë¸
â”‚
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ authController.js    # ì¸ì¦ ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”œâ”€â”€ companyController.js # ê±°ë˜ì²˜ CRUD
â”‚   â”œâ”€â”€ reportController.js  # ë³´ê³ ì„œ CRUD
â”‚   â”œâ”€â”€ employeeController.js# ì§ì› ê´€ë¦¬
â”‚   â””â”€â”€ kpiController.js     # KPI ê³„ì‚°
â”‚
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ auth.js
â”‚   â”œâ”€â”€ companies.js
â”‚   â”œâ”€â”€ reports.js
â”‚   â”œâ”€â”€ employees.js
â”‚   â””â”€â”€ kpi.js
â”‚
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ auth.js              # JWT ì¸ì¦
â”‚   â”œâ”€â”€ validate.js          # ì…ë ¥ ê²€ì¦
â”‚   â””â”€â”€ errorHandler.js      # ì—ëŸ¬ ì²˜ë¦¬
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ companyService.js    # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”œâ”€â”€ reportService.js
â”‚   â”œâ”€â”€ kpiService.js
â”‚   â””â”€â”€ excelService.js
â”‚
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ logger.js
â”‚   â””â”€â”€ validator.js
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ init-db.js           # DB ì´ˆê¸°í™”
â”‚   â””â”€â”€ migrate.js           # ë§ˆì´ê·¸ë ˆì´ì…˜
â”‚
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package.json
â””â”€â”€ server.js
```

---

## 2. Config íŒŒì¼

### 2-1. database.js

**backend/config/database.js:**

```javascript
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';

dotenv.config();

let pool;

export async function createPool() {
  if (!pool) {
    pool = mysql.createPool({
      uri: process.env.DATABASE_URL,
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0,
      enableKeepAlive: true,
      keepAliveInitialDelay: 0
    });

    console.log('âœ… MySQL Pool ìƒì„± ì™„ë£Œ');
  }

  return pool;
}

export async function getConnection() {
  if (!pool) {
    await createPool();
  }

  return pool.getConnection();
}

export default pool;
```

### 2-2. auth.js

**backend/config/auth.js:**

```javascript
import dotenv from 'dotenv';

dotenv.config();

export const authConfig = {
  jwt: {
    secret: process.env.JWT_SECRET || 'default_secret_change_in_production',
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '30d'
  },
  bcrypt: {
    saltRounds: 10
  }
};
```

---

## 3. Models

### 3-1. Company.js

**backend/models/Company.js:**

```javascript
import { createPool } from '../config/database.js';

class Company {
  static async findAll(filters = {}) {
    const pool = await createPool();
    let query = 'SELECT * FROM companies WHERE 1=1';
    const params = [];

    if (filters.manager) {
      query += ' AND internalManager = ?';
      params.push(filters.manager);
    }

    if (filters.status) {
      query += ' AND businessStatus = ?';
      params.push(filters.status);
    }

    query += ' ORDER BY createdAt DESC';

    const [rows] = await pool.execute(query, params);
    return rows;
  }

  static async findById(id) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM companies WHERE id = ?',
      [id]
    );
    return rows[0];
  }

  static async findByKeyValue(keyValue) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM companies WHERE keyValue = ?',
      [keyValue]
    );
    return rows[0];
  }

  static async create(data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `INSERT INTO companies (
        keyValue, companyNameERP, finalCompanyName,
        companyCode, representative, internalManager,
        externalManager, businessStatus, accumulatedSales,
        accumulatedCollection, accountsReceivable,
        salesProduct, businessActivity, remarks, updatedBy
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        data.keyValue,
        data.companyNameERP,
        data.finalCompanyName,
        data.companyCode,
        data.representative,
        data.internalManager,
        data.externalManager,
        data.businessStatus || 'ê±°ë˜ì¤‘',
        data.accumulatedSales || 0,
        data.accumulatedCollection || 0,
        data.accountsReceivable || 0,
        data.salesProduct,
        data.businessActivity,
        data.remarks,
        data.updatedBy
      ]
    );
    return result.insertId;
  }

  static async update(id, data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE companies SET
        companyNameERP = ?,
        finalCompanyName = ?,
        companyCode = ?,
        representative = ?,
        internalManager = ?,
        externalManager = ?,
        businessStatus = ?,
        accumulatedSales = ?,
        accumulatedCollection = ?,
        accountsReceivable = ?,
        lastPaymentDate = ?,
        lastPaymentAmount = ?,
        salesProduct = ?,
        businessActivity = ?,
        remarks = ?,
        updatedBy = ?
      WHERE id = ?`,
      [
        data.companyNameERP,
        data.finalCompanyName,
        data.companyCode,
        data.representative,
        data.internalManager,
        data.externalManager,
        data.businessStatus,
        data.accumulatedSales,
        data.accumulatedCollection,
        data.accountsReceivable,
        data.lastPaymentDate,
        data.lastPaymentAmount,
        data.salesProduct,
        data.businessActivity,
        data.remarks,
        data.updatedBy,
        id
      ]
    );
    return result.affectedRows > 0;
  }

  static async delete(id) {
    const pool = await createPool();
    const [result] = await pool.execute(
      'DELETE FROM companies WHERE id = ?',
      [id]
    );
    return result.affectedRows > 0;
  }

  static async findByManager(manager) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM companies WHERE internalManager = ? ORDER BY companyNameERP',
      [manager]
    );
    return rows;
  }
}

export default Company;
```

### 3-2. Employee.js

**backend/models/Employee.js:**

```javascript
import { createPool } from '../config/database.js';
import bcrypt from 'bcryptjs';

class Employee {
  static async findAll() {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT id, username, name, email, phone, department,
              role, position, isActive, lastLogin, createdAt
       FROM employees
       ORDER BY department, name`
    );
    return rows;
  }

  static async findById(id) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT id, username, name, email, phone, department,
              role, position, isActive, lastLogin, createdAt
       FROM employees WHERE id = ?`,
      [id]
    );
    return rows[0];
  }

  static async findByUsername(username) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM employees WHERE username = ?',
      [username]
    );
    return rows[0];
  }

  static async create(data) {
    const pool = await createPool();
    const hashedPassword = await bcrypt.hash(data.password, 10);

    const [result] = await pool.execute(
      `INSERT INTO employees (
        username, password, name, email, phone,
        department, role, position, isActive
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        data.username,
        hashedPassword,
        data.name,
        data.email,
        data.phone,
        data.department,
        data.role || 'sales',
        data.position,
        true
      ]
    );
    return result.insertId;
  }

  static async update(id, data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE employees SET
        name = ?, email = ?, phone = ?,
        department = ?, role = ?, position = ?,
        isActive = ?
      WHERE id = ?`,
      [
        data.name,
        data.email,
        data.phone,
        data.department,
        data.role,
        data.position,
        data.isActive,
        id
      ]
    );
    return result.affectedRows > 0;
  }

  static async updatePassword(id, newPassword) {
    const pool = await createPool();
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    const [result] = await pool.execute(
      'UPDATE employees SET password = ? WHERE id = ?',
      [hashedPassword, id]
    );
    return result.affectedRows > 0;
  }

  static async verifyPassword(plainPassword, hashedPassword) {
    return await bcrypt.compare(plainPassword, hashedPassword);
  }

  static async updateLastLogin(id) {
    const pool = await createPool();
    await pool.execute(
      'UPDATE employees SET lastLogin = NOW() WHERE id = ?',
      [id]
    );
  }

  static async delete(id) {
    const pool = await createPool();
    const [result] = await pool.execute(
      'UPDATE employees SET isActive = false WHERE id = ?',
      [id]
    );
    return result.affectedRows > 0;
  }
}

export default Employee;
```

### 3-3. Report.js

**backend/models/Report.js:**

```javascript
import { createPool } from '../config/database.js';

class Report {
  static async findAll(filters = {}) {
    const pool = await createPool();
    let query = 'SELECT * FROM reports WHERE 1=1';
    const params = [];

    if (filters.submittedBy) {
      query += ' AND submittedBy = ?';
      params.push(filters.submittedBy);
    }

    if (filters.status) {
      query += ' AND status = ?';
      params.push(filters.status);
    }

    if (filters.startDate) {
      query += ' AND submittedDate >= ?';
      params.push(filters.startDate);
    }

    if (filters.endDate) {
      query += ' AND submittedDate <= ?';
      params.push(filters.endDate);
    }

    query += ' ORDER BY submittedDate DESC';

    const [rows] = await pool.execute(query, params);
    return rows;
  }

  static async findById(id) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM reports WHERE reportId = ?',
      [id]
    );
    return rows[0];
  }

  static async create(data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `INSERT INTO reports (
        submittedBy, companyId, reportType,
        content, status
      ) VALUES (?, ?, ?, ?, 'pending')`,
      [
        data.submittedBy,
        data.companyId,
        data.reportType,
        data.content
      ]
    );
    return result.insertId;
  }

  static async update(id, data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE reports SET
        reportType = ?,
        content = ?
      WHERE reportId = ? AND status = 'pending'`,
      [
        data.reportType,
        data.content,
        id
      ]
    );
    return result.affectedRows > 0;
  }

  static async approve(id, confirmedBy, comment = '') {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE reports SET
        status = 'confirmed',
        confirmedBy = ?,
        confirmedDate = NOW(),
        adminComment = ?
      WHERE reportId = ? AND status = 'pending'`,
      [confirmedBy, comment, id]
    );
    return result.affectedRows > 0;
  }

  static async reject(id, confirmedBy, comment) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `UPDATE reports SET
        status = 'rejected',
        confirmedBy = ?,
        confirmedDate = NOW(),
        adminComment = ?
      WHERE reportId = ? AND status = 'pending'`,
      [confirmedBy, comment, id]
    );
    return result.affectedRows > 0;
  }

  static async findByUser(username) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM reports WHERE submittedBy = ? ORDER BY submittedDate DESC',
      [username]
    );
    return rows;
  }

  static async findPending() {
    const pool = await createPool();
    const [rows] = await pool.execute(
      'SELECT * FROM reports WHERE status = ? ORDER BY submittedDate ASC',
      ['pending']
    );
    return rows;
  }
}

export default Report;
```

### 3-4. ChangeHistory.js

**backend/models/ChangeHistory.js:**

```javascript
import { createPool } from '../config/database.js';

class ChangeHistory {
  static async create(data) {
    const pool = await createPool();
    const [result] = await pool.execute(
      `INSERT INTO change_history (
        targetTable, targetId, operation,
        userId, beforeData, afterData,
        ipAddress, userAgent
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        data.targetTable,
        data.targetId,
        data.operation,
        data.userId,
        JSON.stringify(data.beforeData),
        JSON.stringify(data.afterData),
        data.ipAddress,
        data.userAgent
      ]
    );
    return result.insertId;
  }

  static async findByTarget(tableName, targetId) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT * FROM change_history
       WHERE targetTable = ? AND targetId = ?
       ORDER BY createdAt DESC`,
      [tableName, targetId]
    );
    return rows;
  }

  static async findByUser(userId, limit = 50) {
    const pool = await createPool();
    const [rows] = await pool.execute(
      `SELECT * FROM change_history
       WHERE userId = ?
       ORDER BY createdAt DESC
       LIMIT ?`,
      [userId, limit]
    );
    return rows;
  }
}

export default ChangeHistory;
```

---

## 4. Controllers

### 4-1. authController.js

**backend/controllers/authController.js:**

```javascript
import jwt from 'jsonwebtoken';
import Employee from '../models/Employee.js';
import { authConfig } from '../config/auth.js';

class AuthController {
  static async login(req, res, next) {
    try {
      const { username, password } = req.body;

      // ì‚¬ìš©ì ì¡°íšŒ
      const employee = await Employee.findByUsername(username);
      if (!employee) {
        return res.status(401).json({
          success: false,
          error: { message: 'ì‚¬ìš©ìëª… ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤' }
        });
      }

      // í™œì„± ê³„ì • í™•ì¸
      if (!employee.isActive) {
        return res.status(403).json({
          success: false,
          error: { message: 'ë¹„í™œì„±í™”ëœ ê³„ì •ì…ë‹ˆë‹¤' }
        });
      }

      // ë¹„ë°€ë²ˆí˜¸ í™•ì¸
      const isValid = await Employee.verifyPassword(password, employee.password);
      if (!isValid) {
        return res.status(401).json({
          success: false,
          error: { message: 'ì‚¬ìš©ìëª… ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤' }
        });
      }

      // JWT í† í° ìƒì„±
      const token = jwt.sign(
        {
          id: employee.id,
          username: employee.username,
          role: employee.role,
          name: employee.name
        },
        authConfig.jwt.secret,
        { expiresIn: authConfig.jwt.expiresIn }
      );

      const refreshToken = jwt.sign(
        { id: employee.id },
        authConfig.jwt.secret,
        { expiresIn: authConfig.jwt.refreshExpiresIn }
      );

      // ë§ˆì§€ë§‰ ë¡œê·¸ì¸ ì—…ë°ì´íŠ¸
      await Employee.updateLastLogin(employee.id);

      res.json({
        success: true,
        data: {
          token,
          refreshToken,
          user: {
            id: employee.id,
            username: employee.username,
            name: employee.name,
            role: employee.role,
            department: employee.department
          }
        },
        message: 'ë¡œê·¸ì¸ ì„±ê³µ'
      });

    } catch (error) {
      next(error);
    }
  }

  static async logout(req, res, next) {
    try {
      res.json({
        success: true,
        message: 'ë¡œê·¸ì•„ì›ƒ ë˜ì—ˆìŠµë‹ˆë‹¤'
      });
    } catch (error) {
      next(error);
    }
  }

  static async refresh(req, res, next) {
    try {
      const { refreshToken } = req.body;

      const decoded = jwt.verify(refreshToken, authConfig.jwt.secret);
      const employee = await Employee.findById(decoded.id);

      if (!employee || !employee.isActive) {
        return res.status(401).json({
          success: false,
          error: { message: 'ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤' }
        });
      }

      const newToken = jwt.sign(
        {
          id: employee.id,
          username: employee.username,
          role: employee.role,
          name: employee.name
        },
        authConfig.jwt.secret,
        { expiresIn: authConfig.jwt.expiresIn }
      );

      res.json({
        success: true,
        data: { token: newToken },
        message: 'í† í°ì´ ê°±ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async getMe(req, res, next) {
    try {
      const employee = await Employee.findById(req.user.id);

      res.json({
        success: true,
        data: {
          id: employee.id,
          username: employee.username,
          name: employee.name,
          email: employee.email,
          phone: employee.phone,
          department: employee.department,
          role: employee.role,
          position: employee.position
        }
      });

    } catch (error) {
      next(error);
    }
  }
}

export default AuthController;
```

### 4-2. companyController.js

**backend/controllers/companyController.js:**

```javascript
import Company from '../models/Company.js';
import ChangeHistory from '../models/ChangeHistory.js';

class CompanyController {
  static async getAll(req, res, next) {
    try {
      const filters = {
        manager: req.query.manager,
        status: req.query.status
      };

      const companies = await Company.findAll(filters);

      res.json({
        success: true,
        data: { companies }
      });

    } catch (error) {
      next(error);
    }
  }

  static async getById(req, res, next) {
    try {
      const company = await Company.findById(req.params.id);

      if (!company) {
        return res.status(404).json({
          success: false,
          error: { message: 'ê±°ë˜ì²˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' }
        });
      }

      res.json({
        success: true,
        data: company
      });

    } catch (error) {
      next(error);
    }
  }

  static async create(req, res, next) {
    try {
      const companyData = {
        ...req.body,
        updatedBy: req.user.name
      };

      const companyId = await Company.create(companyData);

      // ë³€ê²½ ì´ë ¥ ê¸°ë¡
      await ChangeHistory.create({
        targetTable: 'companies',
        targetId: companyId,
        operation: 'CREATE',
        userId: req.user.username,
        beforeData: null,
        afterData: companyData,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.status(201).json({
        success: true,
        data: { id: companyId },
        message: 'ê±°ë˜ì²˜ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async update(req, res, next) {
    try {
      const companyId = req.params.id;
      const beforeData = await Company.findById(companyId);

      if (!beforeData) {
        return res.status(404).json({
          success: false,
          error: { message: 'ê±°ë˜ì²˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' }
        });
      }

      const companyData = {
        ...req.body,
        updatedBy: req.user.name
      };

      await Company.update(companyId, companyData);

      // ë³€ê²½ ì´ë ¥ ê¸°ë¡
      await ChangeHistory.create({
        targetTable: 'companies',
        targetId: companyId,
        operation: 'UPDATE',
        userId: req.user.username,
        beforeData,
        afterData: companyData,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({
        success: true,
        message: 'ê±°ë˜ì²˜ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async delete(req, res, next) {
    try {
      const companyId = req.params.id;
      const beforeData = await Company.findById(companyId);

      if (!beforeData) {
        return res.status(404).json({
          success: false,
          error: { message: 'ê±°ë˜ì²˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' }
        });
      }

      await Company.delete(companyId);

      // ë³€ê²½ ì´ë ¥ ê¸°ë¡
      await ChangeHistory.create({
        targetTable: 'companies',
        targetId: companyId,
        operation: 'DELETE',
        userId: req.user.username,
        beforeData,
        afterData: null,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.json({
        success: true,
        message: 'ê±°ë˜ì²˜ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async getMy(req, res, next) {
    try {
      const companies = await Company.findByManager(req.user.name);

      res.json({
        success: true,
        data: { companies }
      });

    } catch (error) {
      next(error);
    }
  }
}

export default CompanyController;
```

### 4-3. reportController.js

**backend/controllers/reportController.js:**

```javascript
import Report from '../models/Report.js';
import ChangeHistory from '../models/ChangeHistory.js';

class ReportController {
  static async getAll(req, res, next) {
    try {
      const filters = {
        submittedBy: req.query.submittedBy,
        status: req.query.status,
        startDate: req.query.startDate,
        endDate: req.query.endDate
      };

      const reports = await Report.findAll(filters);

      res.json({
        success: true,
        data: { reports }
      });

    } catch (error) {
      next(error);
    }
  }

  static async getById(req, res, next) {
    try {
      const report = await Report.findById(req.params.id);

      if (!report) {
        return res.status(404).json({
          success: false,
          error: { message: 'ë³´ê³ ì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' }
        });
      }

      res.json({
        success: true,
        data: report
      });

    } catch (error) {
      next(error);
    }
  }

  static async create(req, res, next) {
    try {
      const reportData = {
        ...req.body,
        submittedBy: req.user.id
      };

      const reportId = await Report.create(reportData);

      // ë³€ê²½ ì´ë ¥ ê¸°ë¡
      await ChangeHistory.create({
        targetTable: 'reports',
        targetId: reportId,
        operation: 'CREATE',
        userId: req.user.username,
        beforeData: null,
        afterData: reportData,
        ipAddress: req.ip,
        userAgent: req.headers['user-agent']
      });

      res.status(201).json({
        success: true,
        data: { reportId },
        message: 'ë³´ê³ ì„œê°€ ì œì¶œë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async update(req, res, next) {
    try {
      const reportId = req.params.id;
      const beforeData = await Report.findById(reportId);

      if (!beforeData) {
        return res.status(404).json({
          success: false,
          error: { message: 'ë³´ê³ ì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' }
        });
      }

      // ë³¸ì¸ ë³´ê³ ì„œë§Œ ìˆ˜ì • ê°€ëŠ¥
      if (beforeData.submittedBy !== req.user.id && req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: { message: 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤' }
        });
      }

      const updated = await Report.update(reportId, req.body);

      if (!updated) {
        return res.status(400).json({
          success: false,
          error: { message: 'ëŒ€ê¸° ìƒíƒœì˜ ë³´ê³ ì„œë§Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤' }
        });
      }

      res.json({
        success: true,
        message: 'ë³´ê³ ì„œê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async approve(req, res, next) {
    try {
      const reportId = req.params.id;
      const { comment } = req.body;

      const updated = await Report.approve(reportId, req.user.id, comment);

      if (!updated) {
        return res.status(400).json({
          success: false,
          error: { message: 'ëŒ€ê¸° ìƒíƒœì˜ ë³´ê³ ì„œë§Œ ìŠ¹ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤' }
        });
      }

      res.json({
        success: true,
        message: 'ë³´ê³ ì„œê°€ ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async reject(req, res, next) {
    try {
      const reportId = req.params.id;
      const { comment } = req.body;

      if (!comment) {
        return res.status(400).json({
          success: false,
          error: { message: 'ë°˜ë ¤ ì‚¬ìœ ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”' }
        });
      }

      const updated = await Report.reject(reportId, req.user.id, comment);

      if (!updated) {
        return res.status(400).json({
          success: false,
          error: { message: 'ëŒ€ê¸° ìƒíƒœì˜ ë³´ê³ ì„œë§Œ ë°˜ë ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤' }
        });
      }

      res.json({
        success: true,
        message: 'ë³´ê³ ì„œê°€ ë°˜ë ¤ë˜ì—ˆìŠµë‹ˆë‹¤'
      });

    } catch (error) {
      next(error);
    }
  }

  static async getMy(req, res, next) {
    try {
      const reports = await Report.findByUser(req.user.id);

      res.json({
        success: true,
        data: { reports }
      });

    } catch (error) {
      next(error);
    }
  }
}

export default ReportController;
```

---

## 5. Routes

### 5-1. auth.js

**backend/routes/auth.js:**

```javascript
import express from 'express';
import AuthController from '../controllers/authController.js';
import { authMiddleware } from '../middleware/auth.js';

const router = express.Router();

router.post('/login', AuthController.login);
router.post('/logout', authMiddleware, AuthController.logout);
router.post('/refresh', AuthController.refresh);
router.get('/me', authMiddleware, AuthController.getMe);

export default router;
```

### 5-2. companies.js

**backend/routes/companies.js:**

```javascript
import express from 'express';
import CompanyController from '../controllers/companyController.js';
import { authMiddleware, isAdmin } from '../middleware/auth.js';

const router = express.Router();

// ëª¨ë“  ë¼ìš°íŠ¸ì— ì¸ì¦ í•„ìš”
router.use(authMiddleware);

router.get('/', CompanyController.getAll);
router.get('/my', CompanyController.getMy);
router.get('/:id', CompanyController.getById);
router.post('/', CompanyController.create);
router.put('/:id', CompanyController.update);
router.delete('/:id', isAdmin, CompanyController.delete);

export default router;
```

### 5-3. reports.js

**backend/routes/reports.js:**

```javascript
import express from 'express';
import ReportController from '../controllers/reportController.js';
import { authMiddleware, isAdmin } from '../middleware/auth.js';

const router = express.Router();

router.use(authMiddleware);

router.get('/', ReportController.getAll);
router.get('/my', ReportController.getMy);
router.get('/:id', ReportController.getById);
router.post('/', ReportController.create);
router.put('/:id', ReportController.update);
router.put('/:id/approve', isAdmin, ReportController.approve);
router.put('/:id/reject', isAdmin, ReportController.reject);

export default router;
```

---

## 6. Middleware

### 6-1. auth.js

**backend/middleware/auth.js:**

```javascript
import jwt from 'jsonwebtoken';
import { authConfig } from '../config/auth.js';

export function authMiddleware(req, res, next) {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: { message: 'ì¸ì¦ í† í°ì´ ì—†ìŠµë‹ˆë‹¤' }
      });
    }

    const token = authHeader.substring(7);
    const decoded = jwt.verify(token, authConfig.jwt.secret);

    req.user = decoded;
    next();

  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        error: { message: 'í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤' }
      });
    }

    return res.status(401).json({
      success: false,
      error: { message: 'ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤' }
    });
  }
}

export function isAdmin(req, res, next) {
  if (req.user.role !== 'admin') {
    return res.status(403).json({
      success: false,
      error: { message: 'ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤' }
    });
  }
  next();
}
```

### 6-2. errorHandler.js

**backend/middleware/errorHandler.js:**

```javascript
export function errorHandler(err, req, res, next) {
  console.error('Error:', err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';

  res.status(statusCode).json({
    success: false,
    error: {
      message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  });
}
```

---

## 7. Services

### 7-1. kpiService.js

**backend/services/kpiService.js:**

```javascript
import { createPool } from '../config/database.js';

class KPIService {
  static async calculateUserKPI(userId) {
    const pool = await createPool();

    // ê±°ë˜ì²˜ í†µê³„
    const [companies] = await pool.execute(
      `SELECT
        COUNT(*) as total_companies,
        SUM(accumulatedSales) as total_sales,
        SUM(accumulatedCollection) as total_collection,
        SUM(accountsReceivable) as total_receivables
       FROM companies
       WHERE internalManager = (SELECT name FROM employees WHERE id = ?)`,
      [userId]
    );

    // ë³´ê³ ì„œ í†µê³„
    const [reports] = await pool.execute(
      `SELECT
        COUNT(*) as total_reports,
        SUM(CASE WHEN status = 'confirmed' THEN 1 ELSE 0 END) as approved_reports
       FROM reports
       WHERE submittedBy = ?`,
      [userId]
    );

    const companyData = companies[0];
    const reportData = reports[0];

    return {
      companies: {
        total: companyData.total_companies || 0,
        totalSales: companyData.total_sales || 0,
        totalCollection: companyData.total_collection || 0,
        totalReceivables: companyData.total_receivables || 0
      },
      reports: {
        total: reportData.total_reports || 0,
        approved: reportData.approved_reports || 0,
        approvalRate: reportData.total_reports > 0
          ? (reportData.approved_reports / reportData.total_reports * 100).toFixed(2)
          : 0
      }
    };
  }
}

export default KPIService;
```

---

## 8. Utils

### 8-1. logger.js

**backend/utils/logger.js:**

```javascript
export function log(level, message, data = {}) {
  const timestamp = new Date().toISOString();
  console.log(JSON.stringify({
    timestamp,
    level,
    message,
    ...data
  }));
}

export const logger = {
  info: (message, data) => log('INFO', message, data),
  error: (message, data) => log('ERROR', message, data),
  warn: (message, data) => log('WARN', message, data),
  debug: (message, data) => log('DEBUG', message, data)
};
```

---

## 9. Scripts

### 9-1. migrate.js

**backend/scripts/migrate.js:**

```javascript
import { createPool } from '../config/database.js';
import fs from 'fs';

async function migrate() {
  const pool = await createPool();

  try {
    // backup.json ì½ê¸°
    const backupData = JSON.parse(
      fs.readFileSync('./backup.json', 'utf8')
    );

    console.log('ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘...');

    // Companies
    for (const company of backupData.data.companies || []) {
      await pool.execute(
        `INSERT IGNORE INTO companies (keyValue, companyNameERP, finalCompanyName, ...)
         VALUES (?, ?, ?, ...)`,
        [company.keyValue, company.companyNameERP, ...]
      );
    }

    console.log(`âœ… ${backupData.data.companies?.length || 0}ê°œ ê±°ë˜ì²˜ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ`);

    // Reports
    for (const report of backupData.data.reports || []) {
      await pool.execute(
        `INSERT INTO reports (submittedBy, companyId, ...)
         VALUES (?, ?, ...)`,
        [report.submittedBy, report.companyId, ...]
      );
    }

    console.log(`âœ… ${backupData.data.reports?.length || 0}ê°œ ë³´ê³ ì„œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ`);

    console.log('ğŸ‰ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ!');

  } catch (error) {
    console.error('âŒ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨:', error);
  } finally {
    process.exit(0);
  }
}

migrate();
```

---

**ë¬¸ì„œ ë²„ì „**: 1.0
**ìµœì¢… ìˆ˜ì •**: 2025-10-04

**ğŸ“¦ ì´ ì½”ë“œë¥¼ backend í´ë”ì— ë°°ì¹˜í•˜ì„¸ìš”!**
